Project Deployment Documentation
-------------------------------------------------------------------------------------------------------------------------
1. Project Overview

    have a Node.js backend and a React frontend application:
      Backend runs on port 8080 (Express + MySQL).
      Frontend runs on port 3000 (React served via serve).
      Both applications are containerized and stored on AWS ECR.
      Both applications are deployed on Kubernetes.
    A single Ingress routes external traffic to frontend (/) and backend (/api).

2. Dockerfiles Summary

Backend Dockerfile (node.js-backend/Dockerfile)
    FROM node:18-alpine
    WORKDIR /app
    COPY package.json package-lock.json ./
    RUN npm ci --only=production
    COPY src ./src
    EXPOSE 8080
    CMD ["node", "src/index.js"]

Frontend Dockerfile (frontend/Dockerfile)
    FROM node:18-alpine AS build
    WORKDIR /app
    COPY package.json package-lock.json ./
    RUN npm ci
    COPY src ./src
    COPY public ./public
    RUN npm run build

    FROM node:18-alpine
    WORKDIR /app
    RUN npm i -g serve
    COPY --from=build /app/build /app/build
    EXPOSE 3000
    CMD ["serve", "-s", "build", "-l", "3000"]

3. Kubernetes Deployment Architecture
    Component	Image (AWS ECR)	Port(s)	Kubernetes Service Type	Accessible At
    Backend	shop-backend	8080	ClusterIP	/api via Ingress
    Frontend	shop-frontend	3000	ClusterIP	/ via Ingress
    Ingress Controller	NGINX Controller	80 (HTTP)	LoadBalancer	Public IP or domain
4. Kubernetes YAML Manifests
    4.1 Backend Deployment + Service
          apiVersion: apps/v1                               # We're creating a Deployment resource from the 'apps/v1' API
          kind: Deployment                                  # This object is a Deployment
          metadata:
            name: backend-deployment                        # Name of the Deployment
            namespace: shop-app                             # Namespace to deploy into
          spec:
            replicas: 1                                     # Number of Pod replicas to run
            selector:
              matchLabels:
                app: backend                                # Selects Pods with label 'app: backend'
            template:                                       # Pod template (what each Pod should look like)
              metadata:
                labels:
                  app: backend                              # Each Pod will be labeled 'app: backend'
              spec:
                imagePullSecrets:
                  - name: ecr-registry                      # Secret used to pull from AWS ECR
                containers:
                  - name: backend
                    image: 48644722.dkr.ecr.us-east-1.amazonaws.com/frontend-backend-application:shop-backend
                    ports:
                      - containerPort: 8080  # Container exposes port 8080

          ---
            apiVersion: v1
            kind: Service
            metadata:
              name: backend-service
              namespace: shop-app
            spec:
              selector:
                app: backend                               # This selects the Pods labeled 'app: backend'
              ports:
                - protocol: TCP
                  port: 80                                 # Exposes this service internally on port 80
                  targetPort: 8080                         # Routes traffic to Pod's containerPort 8080
              type: ClusterIP                              # Makes it only accessible within the cluster


    4.2 Frontend Deployment + Service
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: frontend-deployment
            namespace: shop-app
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: frontend
            template:
              metadata:
                labels:
                  app: frontend
              spec:
                imagePullSecrets:
                  - name: ecr-registry
                containers:
                  - name: frontend
                    image: 48644722.dkr.ecr.us-east-1.amazonaws.com/frontend-backend-application:shop-frontend
                    ports:
                      - containerPort: 3000
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: frontend-service
            namespace: shop-app
          spec:
            selector:
              app: frontend
            ports:
              - protocol: TCP
                port: 80
                targetPort: 3000
            type: ClusterIP

    4.3 Ingress Resource
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: shop-ingress
          namespace: shop-app
          annotations:
            nginx.ingress.kubernetes.io/rewrite-target: /$2
        spec:
          rules:
            - host: shop.44.223.53.100.nip.io   # Replace with your domain or nip.io wildcard
              http:
                paths:
                  - path: /api(/|$)(.*)
                    pathType: Prefix
                    backend:
                      service:
                        name: backend-service
                        port:
                          number: 80
                  - path: /()(.*)
                    pathType: Prefix
                    backend:
                      service:
                        name: frontend-service
                        port:
                          number: 80

5. AWS ECR Setup

    The images are hosted in AWS ECR under:
        Frontend:
        48644722.dkr.ecr.us-east-1.amazonaws.com/frontend-backend-application:shop-frontend
        Backend:
        48644722.dkr.ecr.us-east-1.amazonaws.com/frontend-backend-application:shop-backend

    Create a Kubernetes secret for ECR authentication:

        aws ecr get-login-password --region us-east-1 | \
        kubectl create secret docker-registry ecr-registry \
          --docker-server=486408064722.dkr.ecr.us-east-1.amazonaws.com \
          --docker-username=AWS \
          --docker-password=$(aws ecr get-login-password --region us-east-1) \
          --namespace shop-app

6. Ingress Controller Setup
    Using Helm (recommended)
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        
        helm install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx --create-namespace \
          --set controller.service.type=LoadBalancer
    
    Or via kubectl (quick setup)
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml
    
    Wait for the Ingress Controller's LoadBalancer to get an external IP:    
        kubectl get svc -n ingress-nginx

7. Deployment Commands
    Assuming your YAML files are saved as backend.yaml, frontend.yaml, and ingress.yaml:
        kubectl create namespace shop-app
        # Create the ECR secret
        aws ecr get-login-password --region us-east-1 | \
        kubectl create secret docker-registry ecr-registry \
          --docker-server=486408064722.dkr.ecr.us-east-1.amazonaws.com \
          --docker-username=AWS \
          --docker-password=$(aws ecr get-login-password --region us-east-1) \
          --namespace shop-app

    # Deploy backend and frontend
        kubectl apply -f backend.yaml
        kubectl apply -f frontend.yaml

    # Install ingress controller if not installed
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml

    # Wait until ingress-nginx-controller service gets EXTERNAL-IP
    
    # Deploy ingress rules
        kubectl apply -f ingress.yaml

8. Accessing the Application
    Use the EXTERNAL-IP from the ingress-nginx LoadBalancer service.
    Example URL (using nip.io wildcard):
      http://shop.<EXTERNAL-IP>.nip.io/
    Routes:
      Frontend React app: /
      Backend API: /api
  
9. Pod Naming Convention
    Pods are created by Deployments; their names are auto-generated.
    The pod name format:  
      <deployment-name>-<replicaset-hash>-<random-suffix>
    For example:
      backend-deployment-6b947bfcf5-9zvbd
      frontend-deployment-8484f7ccbd-8slc6
    Pods get new names on rolling updates or restarts.

10. Additional Notes
    Update your React frontend to call the backend API via relative path /api (not hardcoded IP), e.g.:
    fetch('/api')
    The Ingress rewrite-target annotation strips the /api prefix before forwarding to the backend.
    Use namespaces to isolate environments.
    Keep your ECR credentials secure and rotate periodically.
