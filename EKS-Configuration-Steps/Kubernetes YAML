apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
  namespace: dev
  labels:
    app: frontend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: frontend
          image: nginx:latest
          ports:
            - containerPort: 80
          envFrom:
            - configMapRef:
                name: frontend-config
---------------------------------------------------------------
Full Breakdown
ğŸ”¹ 1. apiVersion: apps/v1
â€¢	This specifies which version of the Kubernetes API you are using to create this object.
â€¢	Different types of resources use different API versions.
o	For Deployments, it is apps/v1.
o	For Pods or Services, it might be v1.
ğŸ‘‰ Why it matters:
Kubernetes evolves over time. Specifying the correct API version ensures that Kubernetes interprets the configuration correctly.
________________________________________
ğŸ”¹ 2. kind: Deployment
â€¢	This tells Kubernetes what kind of resource this YAML defines.
â€¢	Deployment is a controller that manages Pods for you â€” it keeps them running, updates them, and can roll back if something goes wrong.
ğŸ‘‰ Why it matters:
If you changed this to Pod, Kubernetes would create only a single unmanaged Pod (no scaling or updates).
________________________________________
ğŸ”¹ 3. metadata:
â€¢	Metadata contains information about the resource â€” mainly used for identification.
Inside metadata:
  name: frontend-deployment
â€¢	The name of this Deployment is frontend-deployment.
â€¢	It must be unique within the namespace.
ğŸ‘‰ Why it matters:
Youâ€™ll use this name when running commands like:
kubectl get deployment frontend-deployment
________________________________________
ğŸ”¹ 4. spec:
â€¢	The specification â€” defines the desired state of the resource.
Everything under spec: tells Kubernetes how this Deployment should behave.
Letâ€™s break it down further ğŸ‘‡
________________________________________
ğŸ”¹ 5. replicas: 2
â€¢	Defines how many Pod replicas (copies) you want Kubernetes to maintain.
â€¢	Here, itâ€™s set to 2, meaning Kubernetes will always ensure 2 identical Pods are running.
ğŸ‘‰ Why it matters:
If one Pod crashes, the Deployment controller automatically creates a new one to maintain 2 Pods.
________________________________________
ğŸ”¹ 6. selector:
â€¢	This tells the Deployment which Pods it should manage.
â€¢	It matches Pods using their labels.
  selector:
    matchLabels:
      app: frontend
â€¢	This means: â€œManage all Pods that have the label app=frontend.â€
ğŸ‘‰ Important:
The labels inside matchLabels must match exactly the labels inside your Pod template (below). Otherwise, the Deployment wonâ€™t know which Pods belong to it.
________________________________________
ğŸ”¹ 7. template:
â€¢	This section defines the Pod template â€” i.e., what each Pod in this Deployment should look like.
When Kubernetes creates Pods for this Deployment, it uses this template.
________________________________________
ğŸ”¹ 8. template.metadata.labels:
    metadata:
      labels:
        app: frontend
â€¢	Assigns the label app=frontend to each Pod created by this Deployment.
ğŸ‘‰ Why it matters:
â€¢	This label connects to:
o	The Deploymentâ€™s selector (so it knows which Pods belong to it)
o	And possibly a Serviceâ€™s selector (so a Service can route traffic to these Pods)
________________________________________
ğŸ”¹ 9. template.spec:
â€¢	Defines what goes inside the Pod â€” the containers, images, ports, and so on.
________________________________________
ğŸ”¹ 10. containers:
â€¢	A Pod can contain one or more containers.
Each container runs an application (like nginx, redis, etc.).
In this case, you have one container defined:
containers:
  - name: frontend
    image: nginx:latest
    ports:
      - containerPort: 80
________________________________________
ğŸ”¹ 11. containers:
â€¢	envFrom.configMapRef â€” loads all key-value pairs from the ConfigMap as environment variables.
